#! /usr/bin/python3.3
# -*- coding: utf8 -*-
'''
Adapter for the models generated by the ComVantage Modeling Method by UNIVIE

@author:     Johannes Pfeffer
        
@version:    0.5

@release:    elephant

'''
from rdflib.plugins.serializers.turtle import SUBJECT
from rdflib.plugins.sparql.algebra import triples

__all__ = ["CV_BPM"]

#Version 4.0.1 - Documentation: https://rdflib.readthedocs.org/en/4.0/
from rdflib import Graph, ConjunctiveGraph, Namespace, URIRef
from rdflib.plugins.memory import IOMemory
from rdflib.namespace import RDF

# GUI related
import tkinter
from tkinter import *
from tkinter.filedialog import askopenfilename

from aof.tools.o_errors import CardinalityError, CLIError

# This class is responsible for providing all methods needed to transform a business process 
# model defined in the CV-Form into a Diagrammatic Orchestration Model
# Later this should be extracted into a separate module

class CV_BPM:
    
    # Namespaces
    NS_MM = Namespace("http://www.comvantage.eu/mm#") # Modeling Method
    NS_O = Namespace("http://comvantage.eu/ontologies/iaf/2013/0/Orchestration.owl#")
    ns=dict(mm=NS_MM, o=NS_O)
    
    # START functions

    def showSelector(self, OPTIONS, message):

        def handler():
            ok()

        def ok():
            master.quit()
            master.destroy()

        master = Tk()
        master.protocol("WM_DELETE_WINDOW", handler)


        var = StringVar(master)
        var.set(OPTIONS[0])
        m = Message(master, text=message)
        m.pack()

        w = OptionMenu(master, var, *OPTIONS)
        w.pack()

        button = Button(master, text="OK", command=ok)
        button.pack()

        master.mainloop()
        return var.get()
    
    def loadModels(self):
        ## Load conjunctive model
        temp = ConjunctiveGraph()

        if self.model_file == "":
            master = Tk()
            self.model_file = askopenfilename(title="Choose Diagrammatic Orchestration Model (TriX)")
            master.quit()
            master.destroy()
        temp.parse(self.model_file,format="trix")
        
        contexts = list()
        for context in temp.contexts():
            contexts.append(context.identifier)
            
        if self.SILENT:
            
            meta = temp.get_context(self.NS_MM.graphmetadata)
            if not (None,RDF.type, self.NS_MM.Orchestration_model) in meta:
                print("There seems to be no Diagrammatic Orchestration Model")
                exit(1)
            if not (None,RDF.type, self.NS_MM.Resource_pool) in meta:
                print("There seems to be no Ressource Pool")
                exit(1)
            self.om_id = meta.value(None,RDF.type, self.NS_MM.Orchestration_model)
            self.rp_id = meta.value(None,RDF.type, self.NS_MM.Resource_pool)
            
        else:    
            self.om_id = URIRef(self.showSelector(contexts, "Please select the graph for the 'Diagrammatic Orchestration Model'"))
            self.rp_id = URIRef(self.showSelector(contexts, "Please select the graph for the 'Resource Pool'"))
           
        # print("Diagrammatic Orchestration Model: %s" % self.om_id)     
        # print("Resource Pool: %s" % self.rp_id)        
        
        self.om = Graph(store=self.store, identifier=str(self.om_id))
        self.om += temp.get_context(self.om_id)
        
        self.rp = Graph(store=self.store, identifier=str(self.rp_id))
        self.rp += temp.get_context(self.rp_id)        

    def printContexts(self):
        for c in self.g.contexts():
            print(c)
    
    def printNamespaces(self):
        for ns in self.g.namespaces():
            print(ns)

    def getEntryPoint(self):
        "Retrieve the start of the Diagrammatic Orchestration Model as URIRef"

        qstr = """
        SELECT ?uri
         
        WHERE { 
            GRAPH <%s> {
               # Find entry point:
               ?rel mm:from_instance [
                   a mm:Suspension_point ;
                   mm:Type "Entry" ] .
               ?rel mm:to_instance ?uri .
            }
        }
        """ % self.om_id
        
        try:
            r = self.g.query(qstr, initNs=self.ns)
            if len(r) == 1:
                r=r.result[0][0]
                self.entrypoint = r
                return r
            else:
                raise CardinalityError(1,len(r),"There must be exactly 1 entry point in a Diagrammatic Orchestration Model")
                exit(1)
        except CardinalityError as e:
            print('Error:', e.message)
        except CLIError as e:
            print('Error:', e.message)
                
    def printEntryPoint(self):
        print(self.getEntryPoint())
    
    def setMetaVariables(self):
        "Retrieve the start of the Diagrammatic Orchestration Model as URIRef"

        qstr = """
        SELECT ?uri ?role ?process ?name
         
        WHERE { 
            GRAPH <%s> {
                ?uri  a mm:Orchestration ;
                                mm:For_role ?role;
                                mm:From_process ?process;
                                mm:Name ?name .
            }
        }
        """ % self.om_id
        
        try:
            r = self.g.query(qstr, initNs=self.ns)
            if len(r) == 1:
                self.processName = r.bindings[0]["?name"]
                self.roleURI = r.bindings[0]["?role"]
                self.process, = r.bindings[0]["?process"]
                self.orchestrationURI = r.bindings[0]["?uri"]
            else:
                raise CardinalityError(1,len(r),"There must be exactly 1 Set of Meta Info assigned to a Diagrammatic Orchestration Model")
        except CardinalityError as e:
            print('Error:', e.message)
    
    def printMetaVariables(self):
        print(list([self.processName, self.roleURI, self.processURI, self.orchestrationURI]))
        
    def getApps(self):
        qstr= """
        CONSTRUCT {
            ?app a mm:Mobile_IT_support_feature_G ;
                a o:App ;
                a o:AppRequest;
                o:hasSuccessor ?successor ;
                o:hasIntent ?intent ;
                o:Name ?name;
                o:AppRequestName ?sf_name;
                o:DisplayName ?name.
            
        }
        WHERE {
            # UNIVIE Diagrammatic Orchestration Model
            GRAPH <%s> {
                ?app  a mm:Mobile_IT_support_feature_G ;
                    mm:Name ?name ; 
                    mm:Represents ?rp_sf .
                    
                    ?relation a mm:Relation_class , mm:Followed_by .
                    OPTIONAL {
                    # Get successors and predecessors
                    ?relation mm:from_instance ?app ;
                        mm:to_instance ?successor .
                    }

            }
            # Ressource pool
            GRAPH <%s> {
                # Retrieve optional information
                OPTIONAL {
                    ?rp_sf a mm:Mobile_IT_support_feature ;
                        mm:Name ?sf_name .
                    }
            }
        
        }
        """  % (self.om_id,self.rp_id)
        #print(qstr)
        res = self.g.query(qstr, initNs=self.ns)
        #print(res.serialize(format="turtle").decode())
        return res
    
    def getSuccessionType(self,app):
        #ToDo: return real succession type!
        
        # For now always return OR-type
        return URIRef(self.NS_O.OR)
    
    # END functions
    
    # Initialization    
        
    def __init__(self, model_file="", SILENT="False"):
        
        # assign model_file
        self.model_file = model_file
        
        # assign silent variable
        self.SILENT = SILENT
        
        # Load the required models
        self.loadModels()  
    
    # Class attributes
    roleURI = ""
    entrypoint = ""
    processName = ""
    orchestrationURI = ""
    processURI = ""
    
    # Graph store
    store = IOMemory()
    g = ConjunctiveGraph(store=store)
    om = Graph(store=store)
    rp = Graph(store=store)
